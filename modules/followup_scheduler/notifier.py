"""Morning digest notifier for the Follow-up Scheduler.

Sends a ranked summary of triggered follow-up activities via email (SMTP)
or Slack webhook.  Both channels are optional â€” if neither is configured,
the digest is printed to stdout only.
"""

import json
import os
import smtplib
import textwrap
from datetime import date
from email.mime.multipart import MIMEMultipart
from email.mime.text import MIMEText

import requests

from shared.logger import get_logger

logger = get_logger("followup_scheduler.notifier")

PRIORITY_ORDER = ["high", "medium", "low"]
PRIORITY_LABELS = {"high": "HIGH", "medium": "MED ", "low": "LOW "}


def format_digest(triggered: list[dict], run_date: date = None) -> str:
    """Format triggered follow-ups as a Markdown digest string.

    Args:
        triggered: List of result dicts from the scheduler, each containing:
                   lead (dict), rule (dict), priority (str), action_taken (str).
        run_date:  Date for the digest header; defaults to today.

    Returns:
        Markdown-formatted string ready for email body or Slack message.
    """
    if run_date is None:
        run_date = date.today()

    counts = {p: 0 for p in PRIORITY_ORDER}
    for item in triggered:
        p = item.get("priority", "medium")
        counts[p] = counts.get(p, 0) + 1

    count_str = ", ".join(
        f"{counts[p]} {p}" for p in PRIORITY_ORDER if counts[p]
    )
    if not count_str:
        count_str = "none"

    lines = [
        f"# BD Follow-up Digest â€” {run_date.strftime('%B %-d, %Y')}",
        f"**{len(triggered)} follow-up(s) triggered:** {count_str}",
        "",
    ]

    if not triggered:
        lines.append("_Nothing triggered today. Pipeline is on track._")
        return "\n".join(lines)

    # Group by priority
    by_priority: dict[str, list] = {p: [] for p in PRIORITY_ORDER}
    for item in triggered:
        p = item.get("priority", "medium")
        by_priority.setdefault(p, []).append(item)

    for priority in PRIORITY_ORDER:
        items = by_priority.get(priority, [])
        if not items:
            continue

        label = {"high": "ðŸ”´ HIGH PRIORITY", "medium": "ðŸŸ¡ MEDIUM PRIORITY", "low": "ðŸ”µ LOW PRIORITY"}[priority]
        lines.append(f"## {label}")
        lines.append("")

        for item in items:
            lead = item["lead"]
            rule = item["rule"]
            action = rule.get("action", {})

            company = lead.get("partner_name") or lead.get("name") or f"Lead #{lead['id']}"
            contact = lead.get("contact_name") or ""
            stage_raw = lead.get("stage_id")
            stage = stage_raw[1] if isinstance(stage_raw, (list, tuple)) and len(stage_raw) == 2 else str(stage_raw or "")
            city = lead.get("city") or ""
            stream = lead.get("x_bd_stream") or ""
            activity_text = action.get("create_activity", "")
            rule_name = rule.get("name", "")

            detail_parts = [p for p in [stage, city, stream] if p]
            detail = " | ".join(detail_parts)

            lines.append(f"### {company}")
            if contact:
                lines.append(f"- **Contact:** {contact}")
            if detail:
                lines.append(f"- **{detail}**")
            lines.append(f"- **Rule:** {rule_name}")
            lines.append(f"- **Action:** {activity_text}")

            move_stage = action.get("move_to_stage")
            if move_stage:
                lines.append(f"- **Moved to stage:** {move_stage}")

            lines.append("")

    lines.append("---")
    lines.append("_Generated by BD Automation Suite_")
    return "\n".join(lines)


def send_email(digest_text: str, recipient: str, run_date: date = None) -> bool:
    """Send the digest via SMTP.

    Reads SMTP_HOST, SMTP_PORT, SMTP_USER, SMTP_PASSWORD from environment.

    Returns True on success, False on failure (logs the error).
    """
    smtp_host = os.getenv("SMTP_HOST", "").strip()
    smtp_port = int(os.getenv("SMTP_PORT", "587"))
    smtp_user = os.getenv("SMTP_USER", "").strip()
    smtp_password = os.getenv("SMTP_PASSWORD", "").strip()

    if not all([smtp_host, smtp_user, smtp_password]):
        logger.warning(
            "Email not configured (SMTP_HOST/SMTP_USER/SMTP_PASSWORD missing) â€” skipping"
        )
        return False

    if run_date is None:
        run_date = date.today()

    subject = f"BD Follow-up Digest â€” {run_date.strftime('%b %-d')}"

    msg = MIMEMultipart("alternative")
    msg["Subject"] = subject
    msg["From"] = smtp_user
    msg["To"] = recipient
    msg.attach(MIMEText(digest_text, "plain", "utf-8"))

    try:
        with smtplib.SMTP(smtp_host, smtp_port) as server:
            server.ehlo()
            server.starttls()
            server.login(smtp_user, smtp_password)
            server.sendmail(smtp_user, [recipient], msg.as_string())
        logger.info("Digest emailed to %s", recipient)
        return True
    except Exception as exc:
        logger.error("Failed to send digest email: %s", exc)
        return False


def send_slack(digest_text: str) -> bool:
    """Post the digest to a Slack webhook.

    Reads SLACK_WEBHOOK_URL from environment.

    Returns True on success, False on failure.
    """
    webhook_url = os.getenv("SLACK_WEBHOOK_URL", "").strip()
    if not webhook_url:
        logger.debug("SLACK_WEBHOOK_URL not set â€” skipping Slack notification")
        return False

    # Slack has a 3000-char limit per block; truncate if needed
    text = digest_text if len(digest_text) <= 3000 else digest_text[:2990] + "\nâ€¦"

    try:
        resp = requests.post(
            webhook_url,
            data=json.dumps({"text": text}),
            headers={"Content-Type": "application/json"},
            timeout=10,
        )
        resp.raise_for_status()
        logger.info("Digest posted to Slack")
        return True
    except Exception as exc:
        logger.error("Failed to post digest to Slack: %s", exc)
        return False


def send_digest(
    triggered: list[dict],
    digest_config: dict,
    run_date: date = None,
) -> None:
    """Format and dispatch the morning digest via configured channels.

    Always prints to stdout.  Sends email / Slack based on digest_config
    (loaded from the 'digest' key in followup_rules.yaml).

    Args:
        triggered:     List of triggered follow-up result dicts.
        digest_config: Dict from YAML, e.g. {enabled, channel, recipient}.
        run_date:      Reference date; defaults to today.
    """
    if run_date is None:
        run_date = date.today()

    text = format_digest(triggered, run_date)

    # Always print to stdout
    print("\n" + text + "\n")

    if not digest_config.get("enabled", True):
        logger.debug("Digest notifications disabled in config")
        return

    channel = digest_config.get("channel", "email")
    recipient = digest_config.get("recipient", os.getenv("NOTIFICATION_EMAIL", ""))

    if channel == "email" and recipient:
        send_email(text, recipient, run_date)
    elif channel == "slack":
        send_slack(text)
    elif channel == "both":
        if recipient:
            send_email(text, recipient, run_date)
        send_slack(text)
    else:
        logger.debug("No notification channel configured")
